# Distill Roadmap

## 완료 (Done)

| 항목 | 커밋 |
|------|------|
| TS MVP — MCP 서버, 5개 도구 (learn, recall, profile, digest, memory) | `f6ebfa3` 이전 |
| SQLite + FTS5 저장소 (global/project 이중 스코프) | `f6ebfa3` 이전 |
| .jsonl 파서 + 트랜스크립트 truncation | `f6ebfa3` 이전 |
| "oh-my" prefix 제거 → "distill" | `f6ebfa3` |
| 추출 기준 리디자인: 단방향 → 양방향 Decision Signals | `f6ebfa3` |
| 한글 예제 제거, 의미 기반 감지 도입 | `f6ebfa3` |
| PreCompact/SessionEnd 자동 추출 hook (`src/hooks/distill-hook.ts`) | `f6ebfa3` 이전 |

---

## Phase 1: 룰 생성/진화

### 목표

축적된 knowledge → `.claude/rules/distill-*.md` 파일 자동 생성/업데이트

### Step 1: 추출 프롬프트 맥락 보존

결론만 추출하던 것을 결론 + 이유(WHY)를 함께 추출하도록 변경.

**현재** (`src/extractor/prompts.ts` Rules 섹션):
```
- "content" must be a self-contained statement (understandable without the conversation)
```

**변경**:
```
- "content" must include both the conclusion AND the reasoning
- For decisions: WHAT was decided AND WHY
  e.g. "Chose SQLite over PostgreSQL because no server dependency needed for CLI tool"
- For corrections: WHAT was wrong AND WHAT replaced it AND WHY
  e.g. "Don't use `any` — use `unknown` instead, because `any` bypasses all type checking"
```

**수정 파일**: `src/extractor/prompts.ts`, `shared/prompts.md`

### Step 2: `crystallize` action 추가

`memory` 도구 (`src/tools/memory.ts`)에 `crystallize` action 추가.
축적된 chunks를 분석해서 룰 파일 생성/업데이트.

**동작**:
1. 모든 knowledge chunk 읽기 (both scopes)
2. 기존 `distill-*.md` 룰 파일 읽기 (있으면)
3. LLM에 전달 → 그룹 분석 + 기존 룰 대비 create/update/remove 판단
4. `.claude/rules/distill-{topic}.md` 파일 생성 또는 업데이트
5. 보고서 반환: 생성/수정/삭제된 룰 파일 목록

**룰 파일 형식**:
```markdown
# {Topic}
> Auto-generated by Distill from {N} decisions (last updated: {date})
- Rule: [conclusion] — because [reasoning]
## Sources
- {chunk_id}: "{preview}"
```

**scope별 경로** (개인 전용):
- global → `~/.claude/rules/distill-{topic}.md`
- project → `<project>/.claude/rules/distill-{topic}.md` + `.gitignore`에 `distill-*.md` 추가

**crystallize 프롬프트** (LLM에 기존 룰 포함):
```
You are a knowledge consolidation engine.

## Input
1. Knowledge entries accumulated from multiple AI coding sessions
2. Existing rule files (if any) previously generated by Distill

## Task
- Find groups of entries pointing in the same direction
- Compare against existing rules:
  - If entries REINFORCE an existing rule → increase confidence, add sources
  - If entries CONTRADICT an existing rule → flag for UPDATE with reasoning
  - If entries form a NEW pattern not covered → CREATE new rule
  - If an existing rule has NO supporting entries → flag for REMOVAL

## Output
For each group:
{
  "topic": "kebab-case-topic-name",
  "action": "create" | "update" | "remove",
  "rules": ["Rule with reasoning"],
  "source_ids": ["id1", "id2"],
  "existing_file": "distill-topic.md" (if update/remove)
}

Return a JSON array. If no patterns found, return [].
```

**수정 파일**: `src/tools/memory.ts`, `src/extractor/prompts.ts` (`CRYSTALLIZE_SYSTEM_PROMPT`), `shared/prompts.md`

### Step 3: 충돌 감지 (distill 룰 한정)

extraction 시 기존 `distill-*.md` 룰 파일을 context로 제공.
대화에서 기존 룰과 충돌하는 행위 감지.

**구현**:
- `src/store/types.ts` — KnowledgeType에 `"conflict"` 추가
- `src/extractor/extractor.ts` — 기존 룰 파일 읽기 + 프롬프트에 `<existing_rules>` 주입
- `src/extractor/prompts.ts` — conflict 추출 기준 추가:
  ```
  5. **Rule conflicts**: If existing rules are provided and the conversation
     shows behavior that contradicts a rule, extract as type "conflict".
     Include WHICH rule is contradicted and WHY the user deviated.
  ```
- RawExtraction에 `conflicting_rule?: string` 필드 추가
- `src/tools/learn.ts` — conflict chunk 감지 시 경고 메시지 표시

**수정 파일**: `src/store/types.ts`, `src/extractor/extractor.ts`, `src/extractor/prompts.ts`, `src/tools/learn.ts`, `shared/prompts.md`

### Step 4: 검증

```bash
npm run build  # 0 errors
```

테스트 (기존 .jsonl 세션 파일 직접 활용):
1. `learn` 도구에 `~/.claude/projects/-.../{session-id}.jsonl` 경로 전달 → 추출 확인
2. conflict type chunk 생성 여부 확인
3. `crystallize` 호출 → `.claude/rules/distill-*.md` 파일 생성 확인
4. 동일 `crystallize` 재호출 → 기존 파일 업데이트 확인 (진화)

---

## Phase 2: 사용자 환경 인식

### 목표

distill이 생성한 룰뿐 아니라 사용자가 직접 작성한 **전체 .claude/ 셋업**을 이해하고 충돌 감지.

### 범위

| 대상 | 경로 | 용도 |
|------|------|------|
| Rules | `.claude/rules/*.md` | 사용자 직접 작성 룰 |
| Skills | `.claude/skills/*/SKILL.md` | 스킬 정의 (triggers, uses) |
| Commands | `.claude/commands/*.md` | 커맨드 정의 |
| Agents | `.claude/agents/*.yaml` | 에이전트 정의 |

### 해야 할 것

1. `.claude/` 스캐너 — rules, skills, commands, agents 인벤토리 수집
2. extraction 시 사용자 전체 룰 context 제공 (distill 룰 + 사용자 룰)
3. crystallize가 기존 사용자 룰과 충돌하면 "수정 제안"만 (자동 수정 X)
4. 스킬/에이전트와의 관계 분석 (어떤 결정이 어떤 스킬에 영향을 미치는지)

### 미정 사항

- 사용자 룰 직접 수정 허용 여부 (distill-*.md만 수정 vs 사용자 룰도 수정)
- 스킬 metadata 수정 범위 (triggers 추가/변경 등)
- 인벤토리 캐싱 전략

---

## Phase 3: 팀 공유

### 목표

개인용 룰을 팀 룰로 승격하는 메커니즘.

### 고민거리

- project scope distill 룰을 git 커밋할지 (팀 전체 적용)
- 팀원 간 충돌 해결: A는 X 선호, B는 Y 선호 → 합의 방법
- PR 기반 제안: crystallize → 룰 파일 변경 → PR 생성 → 팀 리뷰
- 개인 룰 vs 팀 룰 분리 (같은 topic에 개인 override 가능?)

---

## 핵심 결정 로그

| 결정 | 이유 |
|------|------|
| 개인 전용 우선 | 팀 공유 메커니즘은 복잡도 높음. 개인용으로 검증 후 확장 |
| Entire 연동 불필요 | Distill hook이 이미 Claude Code 이벤트에서 독립적으로 동작 |
| Phase 1에서 distill 룰만 충돌 감지 | 사용자 전체 .claude/ 환경 인식은 Phase 2 |
| 양방향 Decision Signals | 단방향(사용자→AI 교정)은 AI→사용자 교정을 놓침 |
| 의미 기반 감지 | 키워드 매칭은 다국어 대화에서 실패. 의미 기반이 범용적 |
