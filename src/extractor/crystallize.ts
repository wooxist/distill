import Anthropic from "@anthropic-ai/sdk";
import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync } from "node:fs";
import { join, basename } from "node:path";
import { homedir } from "node:os";
import {
  CRYSTALLIZE_SYSTEM_PROMPT,
  buildCrystallizePrompt,
} from "./prompts.js";
import type { KnowledgeChunk } from "../store/types.js";

/** A single crystallize rule group from LLM */
export interface CrystallizeResult {
  topic: string;
  action: "create" | "update" | "remove";
  rules: string[];
  source_ids: string[];
  existing_file?: string;
}

/** Report of what crystallize did */
export interface CrystallizeReport {
  created: string[];
  updated: string[];
  removed: string[];
  total_rules: number;
}

/**
 * Read all existing distill-*.md rule files from a rules directory.
 */
function readExistingRules(rulesDir: string): string {
  if (!existsSync(rulesDir)) return "";

  const files = readdirSync(rulesDir).filter(
    (f) => f.startsWith("distill-") && f.endsWith(".md")
  );

  if (files.length === 0) return "";

  return files
    .map((f) => {
      const content = readFileSync(join(rulesDir, f), "utf-8");
      return `### ${f}\n${content}`;
    })
    .join("\n\n");
}

/**
 * Write a rule file in the standard Distill format.
 */
function writeRuleFile(
  rulesDir: string,
  topic: string,
  rules: string[],
  sourceIds: string[],
): string {
  if (!existsSync(rulesDir)) {
    mkdirSync(rulesDir, { recursive: true });
  }

  const filename = `distill-${topic}.md`;
  const date = new Date().toISOString().split("T")[0];

  const content = `# ${topic}
> Auto-generated by Distill from ${sourceIds.length} decisions (last updated: ${date})

${rules.map((r) => `- ${r}`).join("\n")}

## Sources
${sourceIds.map((id) => `- ${id}`).join("\n")}
`;

  writeFileSync(join(rulesDir, filename), content, "utf-8");
  return filename;
}

/**
 * Resolve the rules directory for a given scope.
 */
function resolveRulesDir(scope: "global" | "project", projectRoot?: string | null): string | null {
  if (scope === "global") {
    return join(homedir(), ".claude", "rules");
  }
  if (projectRoot) {
    return join(projectRoot, ".claude", "rules");
  }
  return null;
}

/**
 * Run the crystallize pipeline: analyze chunks → generate/update rules.
 */
export async function crystallize(opts: {
  chunks: KnowledgeChunk[];
  model: string;
  projectRoot?: string | null;
}): Promise<CrystallizeReport> {
  const { chunks, model, projectRoot } = opts;

  if (chunks.length === 0) {
    return { created: [], updated: [], removed: [], total_rules: 0 };
  }

  // 1. Read existing rule files from both scopes
  const globalRulesDir = resolveRulesDir("global");
  const projectRulesDir = resolveRulesDir("project", projectRoot);

  let existingRulesText = "";
  if (globalRulesDir) {
    existingRulesText += readExistingRules(globalRulesDir);
  }
  if (projectRulesDir) {
    const projectRules = readExistingRules(projectRulesDir);
    if (projectRules) {
      existingRulesText += (existingRulesText ? "\n\n" : "") + projectRules;
    }
  }

  // 2. Prepare entries for LLM
  const entries = chunks.map((c) => ({
    id: c.id,
    content: c.content,
    type: c.type,
    tags: c.tags,
  }));

  // 3. Call LLM
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    throw new Error("ANTHROPIC_API_KEY environment variable is required for crystallize");
  }

  const client = new Anthropic({ apiKey });
  const response = await client.messages.create({
    model,
    max_tokens: 4096,
    system: CRYSTALLIZE_SYSTEM_PROMPT,
    messages: [
      {
        role: "user",
        content: buildCrystallizePrompt(
          entries,
          existingRulesText || undefined,
        ),
      },
    ],
  });

  const text = response.content
    .filter((b): b is Anthropic.TextBlock => b.type === "text")
    .map((b) => b.text)
    .join("");

  // 4. Parse results
  const results = parseCrystallizeResponse(text);
  if (results.length === 0) {
    return { created: [], updated: [], removed: [], total_rules: 0 };
  }

  // 5. Apply results — write rule files
  const report: CrystallizeReport = {
    created: [],
    updated: [],
    removed: [],
    total_rules: 0,
  };

  // Determine target directory: project scope if available, else global
  const targetDir = projectRulesDir ?? globalRulesDir;
  if (!targetDir) {
    throw new Error("No rules directory available");
  }

  for (const result of results) {
    if (result.action === "remove") {
      const filePath = join(targetDir, result.existing_file ?? `distill-${result.topic}.md`);
      if (existsSync(filePath)) {
        const { unlinkSync } = await import("node:fs");
        unlinkSync(filePath);
        report.removed.push(basename(filePath));
      }
      continue;
    }

    const filename = writeRuleFile(
      targetDir,
      result.topic,
      result.rules,
      result.source_ids,
    );

    if (result.action === "create") {
      report.created.push(filename);
    } else {
      report.updated.push(filename);
    }
    report.total_rules += result.rules.length;
  }

  return report;
}

function parseCrystallizeResponse(text: string): CrystallizeResult[] {
  const jsonMatch = text.match(/\[[\s\S]*\]/);
  if (!jsonMatch) return [];

  try {
    const parsed = JSON.parse(jsonMatch[0]);
    if (!Array.isArray(parsed)) return [];

    return parsed.filter(
      (item): item is CrystallizeResult =>
        typeof item.topic === "string" &&
        ["create", "update", "remove"].includes(item.action) &&
        Array.isArray(item.rules) &&
        Array.isArray(item.source_ids)
    );
  } catch {
    return [];
  }
}
