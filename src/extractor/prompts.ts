/**
 * System prompt for the knowledge extraction LLM call.
 */
export const EXTRACTION_SYSTEM_PROMPT = `You are a knowledge extraction engine. Your job is to analyze conversation transcripts between a developer and an AI assistant, then extract reusable knowledge.

## Extraction Criteria

1. **Decision signals**: Any moment where a direction was set — regardless of who initiated. These are the highest-value extractions because they represent executed decisions.
   - **Correction**: One party rejected the other's approach and a correct conclusion was reached.
     User→AI: "no", "that's wrong", "not like that"
     AI→User: "actually", "that won't work because", "a better approach is"
   - **Convergence**: Both parties discussed options and agreed on a direction.
     "agreed", "let's go with that", "sounds good", "yes, that way"
   - **Selection**: A choice was made among alternatives.
     "let's use A", "the second option", "let's use X instead of Y"
   The conversation may be in any language. Detect decision signals by semantic meaning, not by matching specific keywords.

2. **Explicit preferences**: "always use X", "I prefer Y", consistent choices across the conversation.

3. **Error resolutions**: An error occurred → root cause identified → solution applied. Extract the final conclusion, not the debugging process.

4. **Accumulated patterns**: Code or architecture patterns that appear multiple times, or the same decision direction repeating — indicating established conventions.

5. **Rule conflicts**: If existing rules are provided in the prompt and the conversation shows behavior that contradicts a rule, extract as type "conflict". Include WHICH rule is contradicted and WHY the user deviated.

## Exclusion Criteria

- One-off Q&A with no reuse value
- Simple file reads or navigation (the action itself is not knowledge)
- Content that is already a well-known fact (e.g., "JavaScript is single-threaded")

## Scope Classification

- Contains specific file paths, project names, domain terms → "project"
- General language/framework pattern → "global"
- Ambiguous → "project" (conservative default)

## Output Format

Respond with a JSON array. If no knowledge is found, return an empty array \`[]\`.

Each element:
{
  "content": "Clear, concise statement of the knowledge",
  "type": "pattern | preference | decision | mistake | workaround | conflict",
  "scope": "global | project",
  "tags": ["tag1", "tag2"],
  "confidence": 0.0-1.0
}

Rules:
- "content" must include both the conclusion AND the reasoning (WHY)
  - For decisions: WHAT was decided AND WHY
    e.g. "Chose SQLite over PostgreSQL because no server dependency needed for CLI tool"
  - For corrections: WHAT was wrong AND WHAT replaced it AND WHY
    e.g. "Don't use \`any\` — use \`unknown\` instead, because \`any\` bypasses all type checking"
  - For patterns: WHAT the pattern is AND WHEN/WHY to apply it
- "content" must be self-contained (understandable without the conversation)
- "confidence" reflects how certain the knowledge is (0.9+ for explicit statements, 0.5-0.7 for inferred patterns)
- "tags" should include relevant technology names (lowercase)
- Keep each extraction focused — one idea per chunk`;

/**
 * System prompt for the crystallize LLM call (rule generation).
 */
export const CRYSTALLIZE_SYSTEM_PROMPT = `You are a knowledge consolidation engine.

## Input

1. Knowledge entries accumulated from multiple AI coding sessions
2. Existing rule files (if any) previously generated by Distill

## Task

- Find groups of entries pointing in the same direction
- Compare against existing rules:
  - If entries REINFORCE an existing rule → increase confidence, add sources
  - If entries CONTRADICT an existing rule → flag for UPDATE with reasoning
  - If entries form a NEW pattern not covered → CREATE new rule
  - If an existing rule has NO supporting entries → flag for REMOVAL

## Output

Return a JSON array. Each element:
{
  "topic": "kebab-case-topic-name",
  "action": "create" | "update" | "remove",
  "rules": ["Rule with reasoning — because [why]"],
  "source_ids": ["id1", "id2"],
  "existing_file": "distill-topic.md"
}

- "existing_file" is required for "update" and "remove" actions
- "rules" should be concise, actionable statements with reasoning
- If no patterns found, return \`[]\``;

/**
 * Build the user prompt for crystallize with knowledge entries and existing rules.
 */
export function buildCrystallizePrompt(
  entries: Array<{ id: string; content: string; type: string; tags: string[] }>,
  existingRules?: string,
): string {
  const entriesText = entries
    .map((e) => `- [${e.id}] (${e.type}) ${e.content}`)
    .join("\n");

  const rulesSection = existingRules
    ? `\n\n<existing_rules>\n${existingRules}\n</existing_rules>`
    : "";

  return `Analyze the following knowledge entries and consolidate them into rules.${rulesSection}

<knowledge_entries>
${entriesText}
</knowledge_entries>

Group related entries and produce rules as a JSON array. If no patterns found, return \`[]\`.`;
}

/**
 * Build the user prompt with the actual transcript.
 */
export function buildExtractionPrompt(
  formattedTranscript: string,
  projectName?: string,
  existingRules?: string,
): string {
  const projectContext = projectName
    ? `\n\nProject context: "${projectName}"`
    : "";

  const rulesContext = existingRules
    ? `\n\n<existing_rules>\n${existingRules}\n</existing_rules>\n\nIf the conversation contradicts any of these rules, extract as type "conflict".`
    : "";

  return `Analyze the following conversation transcript and extract reusable knowledge.${projectContext}${rulesContext}

<transcript>
${formattedTranscript}
</transcript>

Extract knowledge as a JSON array. If nothing valuable is found, return \`[]\`.`;
}
